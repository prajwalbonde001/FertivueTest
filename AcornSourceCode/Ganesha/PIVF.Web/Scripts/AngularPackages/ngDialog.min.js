///*! ng-dialog - v0.6.3 (https://github.com/likeastore/ngDialog) */
//!function (a, b) { "undefined" != typeof module && module.exports ? (b("undefined" == typeof angular ? require("angular") : angular), module.exports = "ngDialog") : "function" == typeof define && define.amd ? define(["angular"], b) : b(a.angular) }(this, function (a) {
//    "use strict"; var b = a.module("ngDialog", []), c = a.element, d = a.isDefined, e = (document.body || document.documentElement).style, f = d(e.animation) || d(e.WebkitAnimation) || d(e.MozAnimation) || d(e.MsAnimation) || d(e.OAnimation), g = "animationend webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend", h = "a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]", i = "ngdialog-disabled-animation", j = { html: !1, body: !1 }, k = {}, l = [], m = !1, n = !1; return b.provider("ngDialog", function () {
//        var b = this.defaults = { className: "ngdialog-theme-default", appendClassName: "", disableAnimation: !1, plain: !1, showClose: !0, closeByDocument: !0, closeByEscape: !0, closeByNavigation: !1, appendTo: !1, preCloseCallback: !1, overlay: !0, cache: !0, trapFocus: !0, preserveFocus: !0, ariaAuto: !0, ariaRole: null, ariaLabelledById: null, ariaLabelledBySelector: null, ariaDescribedById: null, ariaDescribedBySelector: null, bodyClassName: "ngdialog-open", width: null, height: null }; this.setForceHtmlReload = function (a) { j.html = a || !1 }, this.setForceBodyReload = function (a) { j.body = a || !1 }, this.setDefaults = function (c) { a.extend(b, c) }, this.setOpenOnePerName = function (a) { n = a || !1 }; var d, e = 0, o = 0, p = {}; this.$get = ["$document", "$templateCache", "$compile", "$q", "$http", "$rootScope", "$timeout", "$window", "$controller", "$injector", function (q, r, s, t, u, v, w, x, y, z) {
//            var A = [], B = { onDocumentKeydown: function (a) { 27 === a.keyCode && C.close("$escape") }, activate: function (a) { var b = a.data("$ngDialogOptions"); b.trapFocus && (a.on("keydown", B.onTrapFocusKeydown), A.body.on("keydown", B.onTrapFocusKeydown)) }, deactivate: function (a) { a.off("keydown", B.onTrapFocusKeydown), A.body.off("keydown", B.onTrapFocusKeydown) }, deactivateAll: function (b) { a.forEach(b, function (b) { var c = a.element(b); B.deactivate(c) }) }, setBodyPadding: function (a) { var b = parseInt(A.body.css("padding-right") || 0, 10); A.body.css("padding-right", b + a + "px"), A.body.data("ng-dialog-original-padding", b), v.$broadcast("ngDialog.setPadding", a) }, resetBodyPadding: function () { var a = A.body.data("ng-dialog-original-padding"); a ? A.body.css("padding-right", a + "px") : A.body.css("padding-right", ""), v.$broadcast("ngDialog.setPadding", 0) }, performCloseDialog: function (a, b) { var c = a.data("$ngDialogOptions"), e = a.attr("id"), h = k[e]; if (h) { if ("undefined" != typeof x.Hammer) { var i = h.hammerTime; i.off("tap", d), i.destroy && i.destroy(), delete h.hammerTime } else a.unbind("click"); 1 === o && A.body.unbind("keydown", B.onDocumentKeydown), a.hasClass("ngdialog-closing") || (o -= 1); var j = a.data("$ngDialogPreviousFocus"); j && j.focus && j.focus(), v.$broadcast("ngDialog.closing", a, b), o = o < 0 ? 0 : o, f && !c.disableAnimation ? (h.$destroy(), a.unbind(g).bind(g, function () { B.closeDialogElement(a, b) }).addClass("ngdialog-closing")) : (h.$destroy(), B.closeDialogElement(a, b)), p[e] && (p[e].resolve({ id: e, value: b, $dialog: a, remainingDialogs: o }), delete p[e]), k[e] && delete k[e], l.splice(l.indexOf(e), 1), l.length || (A.body.unbind("keydown", B.onDocumentKeydown), m = !1) } }, closeDialogElement: function (a, b) { var c = a.data("$ngDialogOptions"); a.remove(), 0 === o && (A.html.removeClass(c.bodyClassName), A.body.removeClass(c.bodyClassName), B.resetBodyPadding()), v.$broadcast("ngDialog.closed", a, b) }, closeDialog: function (b, c) { var d = b.data("$ngDialogPreCloseCallback"); if (d && a.isFunction(d)) { var e = d.call(b, c); if (a.isObject(e)) e.closePromise ? e.closePromise.then(function () { B.performCloseDialog(b, c) }, function () { return !1 }) : e.then(function () { B.performCloseDialog(b, c) }, function () { return !1 }); else { if (e === !1) return !1; B.performCloseDialog(b, c) } } else B.performCloseDialog(b, c) }, onTrapFocusKeydown: function (b) { var c, d = a.element(b.currentTarget); if (d.hasClass("ngdialog")) c = d; else if (c = B.getActiveDialog(), null === c) return; var e = 9 === b.keyCode, f = b.shiftKey === !0; e && B.handleTab(c, b, f) }, handleTab: function (a, b, c) { var d = B.getFocusableElements(a); if (0 === d.length) return void (document.activeElement && document.activeElement.blur && document.activeElement.blur()); var e = document.activeElement, f = Array.prototype.indexOf.call(d, e), g = f === -1, h = 0 === f, i = f === d.length - 1, j = !1; c ? (g || h) && (d[d.length - 1].focus(), j = !0) : (g || i) && (d[0].focus(), j = !0), j && (b.preventDefault(), b.stopPropagation()) }, autoFocus: function (a) { var b = a[0], d = b.querySelector("*[autofocus]"); if (null === d || (d.focus(), document.activeElement !== d)) { var e = B.getFocusableElements(a); if (e.length > 0) return void e[0].focus(); var f = B.filterVisibleElements(b.querySelectorAll("h1,h2,h3,h4,h5,h6,p,span")); if (f.length > 0) { var g = f[0]; c(g).attr("tabindex", "-1").css("outline", "0"), g.focus() } } }, getFocusableElements: function (a) { var b = a[0], c = b.querySelectorAll(h), d = B.filterTabbableElements(c); return B.filterVisibleElements(d) }, filterTabbableElements: function (a) { for (var b = [], d = 0; d < a.length; d++) { var e = a[d]; "-1" !== c(e).attr("tabindex") && b.push(e) } return b }, filterVisibleElements: function (a) { for (var b = [], c = 0; c < a.length; c++) { var d = a[c]; (d.offsetWidth > 0 || d.offsetHeight > 0) && b.push(d) } return b }, getActiveDialog: function () { var a = document.querySelectorAll(".ngdialog"); return 0 === a.length ? null : c(a[a.length - 1]) }, applyAriaAttributes: function (a, b) { if (b.ariaAuto) { if (!b.ariaRole) { var c = B.getFocusableElements(a).length > 0 ? "dialog" : "alertdialog"; b.ariaRole = c } b.ariaLabelledBySelector || (b.ariaLabelledBySelector = "h1,h2,h3,h4,h5,h6"), b.ariaDescribedBySelector || (b.ariaDescribedBySelector = "article,section,p") } b.ariaRole && a.attr("role", b.ariaRole), B.applyAriaAttribute(a, "aria-labelledby", b.ariaLabelledById, b.ariaLabelledBySelector), B.applyAriaAttribute(a, "aria-describedby", b.ariaDescribedById, b.ariaDescribedBySelector) }, applyAriaAttribute: function (a, b, d, e) { if (d && a.attr(b, d), e) { var f = a.attr("id"), g = a[0].querySelector(e); if (!g) return; var h = f + "-" + b; return c(g).attr("id", h), a.attr(b, h), h } }, detectUIRouter: function () { try { return a.module("ui.router"), !0 } catch (b) { return !1 } }, getRouterLocationEventName: function () { return B.detectUIRouter() ? "$stateChangeStart" : "$locationChangeStart" } }, C = {
//                __PRIVATE__: B, open: function (f) {
//                    function g(a, b) { return v.$broadcast("ngDialog.templateLoading", a), u.get(a, b || {}).then(function (b) { return v.$broadcast("ngDialog.templateLoaded", a), b.data || "" }) } function h(b) { return b ? a.isString(b) && q.plain ? b : "boolean" != typeof q.cache || q.cache ? g(b, { cache: r }) : g(b, { cache: !1 }) : "Empty template" } var j = null; if (f = f || {}, !(n && f.name && (j = f.name.toLowerCase().replace(/\s/g, "-") + "-dialog", this.isOpen(j)))) {
//                        var q = a.copy(b), D = ++e; j = j || "ngdialog" + D, l.push(j), "undefined" != typeof q.data && ("undefined" == typeof f.data && (f.data = {}), f.data = a.merge(a.copy(q.data), f.data)), a.extend(q, f); var E; p[j] = E = t.defer(); var F; k[j] = F = a.isObject(q.scope) ? q.scope.$new() : v.$new(); var G, H, I, J = a.extend({}, q.resolve); return a.forEach(J, function (b, c) { J[c] = a.isString(b) ? z.get(b) : z.invoke(b, null, null, c) }), t.all({ template: h(q.template || q.templateUrl), locals: t.all(J) }).then(function (b) {
//                            var e = b.template, f = b.locals; q.showClose && (e += '<div class="ngdialog-close"></div>'); var g = q.overlay ? "" : " ngdialog-no-overlay"; if (G = c('<div id="' + j + '" class="ngdialog' + g + '"></div>'), G.html(q.overlay ? '<div class="ngdialog-overlay"></div><div class="ngdialog-content" role="document">' + e + "</div>" : '<div class="ngdialog-content" role="document">' + e + "</div>"), G.data("$ngDialogOptions", q), F.ngDialogId = j, q.data && a.isString(q.data)) { var h = q.data.replace(/^\s*/, "")[0]; F.ngDialogData = "{" === h || "[" === h ? a.fromJson(q.data) : new String(q.data), F.ngDialogData.ngDialogId = j } else q.data && a.isObject(q.data) && (F.ngDialogData = q.data, F.ngDialogData.ngDialogId = j); if (q.className && G.addClass(q.className), q.appendClassName && G.addClass(q.appendClassName), q.width && (I = G[0].querySelector(".ngdialog-content"), a.isString(q.width) ? I.style.width = q.width : I.style.width = q.width + "px"), q.height && (I = G[0].querySelector(".ngdialog-content"), a.isString(q.height) ? I.style.height = q.height : I.style.height = q.height + "px"), q.disableAnimation && G.addClass(i), H = q.appendTo && a.isString(q.appendTo) ? a.element(document.querySelector(q.appendTo)) : A.body, B.applyAriaAttributes(G, q), q.preCloseCallback) { var k; a.isFunction(q.preCloseCallback) ? k = q.preCloseCallback : a.isString(q.preCloseCallback) && F && (a.isFunction(F[q.preCloseCallback]) ? k = F[q.preCloseCallback] : F.$parent && a.isFunction(F.$parent[q.preCloseCallback]) ? k = F.$parent[q.preCloseCallback] : v && a.isFunction(v[q.preCloseCallback]) && (k = v[q.preCloseCallback])), k && G.data("$ngDialogPreCloseCallback", k) } if (F.closeThisDialog = function (a) { B.closeDialog(G, a) }, q.controller && (a.isString(q.controller) || a.isArray(q.controller) || a.isFunction(q.controller))) {
//                                var l; q.controllerAs && a.isString(q.controllerAs) && (l = q.controllerAs); var n = y(q.controller, a.extend(f, { $scope: F, $element: G }), !0, l); q.bindToController && a.extend(n.instance, { ngDialogId: F.ngDialogId, ngDialogData: F.ngDialogData, closeThisDialog: F.closeThisDialog, confirm: F.confirm }),
//                                    "function" == typeof n ? G.data("$ngDialogControllerController", n()) : G.data("$ngDialogControllerController", n)
//                            } if (w(function () { var a = document.querySelectorAll(".ngdialog"); B.deactivateAll(a), s(G)(F); var b = x.innerWidth - A.body.prop("clientWidth"); A.html.addClass(q.bodyClassName), A.body.addClass(q.bodyClassName); var c = b - (x.innerWidth - A.body.prop("clientWidth")); c > 0 && B.setBodyPadding(c), H.append(G), B.activate(G), q.trapFocus && B.autoFocus(G), q.name ? v.$broadcast("ngDialog.opened", { dialog: G, name: q.name }) : v.$broadcast("ngDialog.opened", G) }), m || (A.body.bind("keydown", B.onDocumentKeydown), m = !0), q.closeByNavigation) { var p = B.getRouterLocationEventName(); v.$on(p, function (a) { B.closeDialog(G) === !1 && a.preventDefault() }) } if (q.preserveFocus && G.data("$ngDialogPreviousFocus", document.activeElement), d = function (a) { var b = !!q.closeByDocument && c(a.target).hasClass("ngdialog-overlay"), d = c(a.target).hasClass("ngdialog-close"); (b || d) && C.close(G.attr("id"), d ? "$closeButton" : "$document") }, "undefined" != typeof x.Hammer) { var r = F.hammerTime = x.Hammer(G[0]); r.on("tap", d) } else G.bind("click", d); return o += 1, C
//                        }), { id: j, closePromise: E.promise, close: function (a) { B.closeDialog(G, a) } }
//                    }
//                }, openConfirm: function (d) { var e = t.defer(), f = a.copy(b); d = d || {}, "undefined" != typeof f.data && ("undefined" == typeof d.data && (d.data = {}), d.data = a.merge(a.copy(f.data), d.data)), a.extend(f, d), f.scope = a.isObject(f.scope) ? f.scope.$new() : v.$new(), f.scope.confirm = function (a) { e.resolve(a); var b = c(document.getElementById(g.id)); B.performCloseDialog(b, a) }; var g = C.open(f); if (g) return g.closePromise.then(function (a) { return a ? e.reject(a.value) : e.reject() }), e.promise }, isOpen: function (a) { var b = c(document.getElementById(a)); return b.length > 0 }, close: function (a, b) { var d = c(document.getElementById(a)); if (d.length) B.closeDialog(d, b); else if ("$escape" === a) { var e = l[l.length - 1]; d = c(document.getElementById(e)), d.data("$ngDialogOptions").closeByEscape && B.closeDialog(d, "$escape") } else C.closeAll(b); return C }, closeAll: function (a) { for (var b = document.querySelectorAll(".ngdialog"), d = b.length - 1; d >= 0; d--) { var e = b[d]; B.closeDialog(c(e), a) } }, getOpenDialogs: function () { return l }, getDefaults: function () { return b }
//            }; return a.forEach(["html", "body"], function (a) { if (A[a] = q.find(a), j[a]) { var b = B.getRouterLocationEventName(); v.$on(b, function () { A[a] = q.find(a) }) } }), C
//        }]
//    }), b.directive("ngDialog", ["ngDialog", function (b) { return { restrict: "A", scope: { ngDialogScope: "=" }, link: function (c, d, e) { d.on("click", function (d) { d.preventDefault(); var f = a.isDefined(c.ngDialogScope) ? c.ngDialogScope : "noScope"; a.isDefined(e.ngDialogClosePrevious) && b.close(e.ngDialogClosePrevious); var g = b.getDefaults(); b.open({ template: e.ngDialog, className: e.ngDialogClass || g.className, appendClassName: e.ngDialogAppendClass, controller: e.ngDialogController, controllerAs: e.ngDialogControllerAs, bindToController: e.ngDialogBindToController, scope: f, data: e.ngDialogData, showClose: "false" !== e.ngDialogShowClose && ("true" === e.ngDialogShowClose || g.showClose), closeByDocument: "false" !== e.ngDialogCloseByDocument && ("true" === e.ngDialogCloseByDocument || g.closeByDocument), closeByEscape: "false" !== e.ngDialogCloseByEscape && ("true" === e.ngDialogCloseByEscape || g.closeByEscape), overlay: "false" !== e.ngDialogOverlay && ("true" === e.ngDialogOverlay || g.overlay), preCloseCallback: e.ngDialogPreCloseCallback || g.preCloseCallback, bodyClassName: e.ngDialogBodyClass || g.bodyClassName }) }) } } }]), b
//});

/*
 * ngDialog - easy modals and popup windows
 * http://github.com/likeastore/ngDialog
 * (c) 2013-2015 MIT License, https://likeastore.com
 */

(function (root, factory) {
    if (typeof module !== 'undefined' && module.exports) {
        // CommonJS
        module.exports = factory(require('angular'));
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(['angular'], factory);
    } else {
        // Global Variables
        factory(root.angular);
    }
}(this, function (angular, undefined) {
    'use strict';

    var m = angular.module('ngDialog', []);

    var $el = angular.element;
    var isDef = angular.isDefined;
    var style = (document.body || document.documentElement).style;
    var animationEndSupport = isDef(style.animation) || isDef(style.WebkitAnimation) || isDef(style.MozAnimation) || isDef(style.MsAnimation) || isDef(style.OAnimation);
    var animationEndEvent = 'animationend webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend';
    var focusableElementSelector = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]';
    var forceBodyReload = false;
    var scope;

    m.provider('ngDialog', function () {
        var defaults = this.defaults = {
            className: 'ngdialog-theme-default',
            plain: false,
            showClose: true,
            closeByDocument: true,
            closeByEscape: true,
            closeByNavigation: false,
            appendTo: false,
            preCloseCallback: false,
            overlay: true,
            cache: true,
            trapFocus: true,
            preserveFocus: true,
            ariaAuto: true,
            ariaRole: null,
            ariaLabelledById: null,
            ariaLabelledBySelector: null,
            ariaDescribedById: null,
            ariaDescribedBySelector: null
        };

        this.setForceBodyReload = function (_useIt) {
            forceBodyReload = _useIt || false;
        };

        this.setDefaults = function (newDefaults) {
            angular.extend(defaults, newDefaults);
        };

        var globalID = 0, dialogsCount = 0, closeByDocumentHandler, defers = {};

        this.$get = ['$document', '$templateCache', '$compile', '$q', '$http', '$rootScope', '$timeout', '$window', '$controller',
            function ($document, $templateCache, $compile, $q, $http, $rootScope, $timeout, $window, $controller) {
                var $body = $document.find('body');
                if (forceBodyReload) {
                    $rootScope.$on('$locationChangeSuccess', function () {
                        $body = $document.find('body');
                    });
                }

                var privateMethods = {
                    onDocumentKeydown: function (event) {
                        if (event.keyCode === 27) {
                            publicMethods.close('$escape');
                        }
                    },

                    activate: function ($dialog) {
                        var options = $dialog.data('$ngDialogOptions');

                        if (options.trapFocus) {
                            $dialog.on('keydown', privateMethods.onTrapFocusKeydown);

                            // Catch rogue changes (eg. after unfocusing everything by clicking a non-focusable element)
                            $body.on('keydown', privateMethods.onTrapFocusKeydown);
                        }
                    },

                    deactivate: function ($dialog) {
                        $dialog.off('keydown', privateMethods.onTrapFocusKeydown);
                        $body.off('keydown', privateMethods.onTrapFocusKeydown);
                    },

                    deactivateAll: function ($all) {
                        angular.forEach(function (el) {
                            var $dialog = angular.element(el);
                            privateMethods.deactivate($dialog);
                        });
                    },

                    setBodyPadding: function (width) {
                        var originalBodyPadding = parseInt(($body.css('padding-right') || 0), 10);
                        $body.css('padding-right', (originalBodyPadding + width) + 'px');
                        $body.data('ng-dialog-original-padding', originalBodyPadding);
                    },

                    resetBodyPadding: function () {
                        var originalBodyPadding = $body.data('ng-dialog-original-padding');
                        if (originalBodyPadding) {
                            $body.css('padding-right', originalBodyPadding + 'px');
                        } else {
                            $body.css('padding-right', '');
                        }
                    },

                    performCloseDialog: function ($dialog, value) {
                        var id = $dialog.attr('id');

                        if (typeof $window.Hammer !== 'undefined') {
                            var hammerTime = scope.hammerTime;
                            hammerTime.off('tap', closeByDocumentHandler);
                            hammerTime.destroy && hammerTime.destroy();
                            delete scope.hammerTime;
                        } else {
                            $dialog.unbind('click');
                        }

                        if (dialogsCount === 1) {
                            $body.unbind('keydown');
                        }

                        if (!$dialog.hasClass("ngdialog-closing")) {
                            dialogsCount -= 1;
                        }

                        var previousFocus = $dialog.data('$ngDialogPreviousFocus');
                        if (previousFocus) {
                            previousFocus.focus();
                        }

                        $rootScope.$broadcast('ngDialog.closing', $dialog);
                        dialogsCount = dialogsCount < 0 ? 0 : dialogsCount;
                        if (animationEndSupport) {
                            scope.$destroy();
                            $dialog.unbind(animationEndEvent).bind(animationEndEvent, function () {
                                $dialog.remove();
                                if (dialogsCount === 0) {
                                    $body.removeClass('ngdialog-open');
                                    privateMethods.resetBodyPadding();
                                }
                                $rootScope.$broadcast('ngDialog.closed', $dialog);
                            }).addClass('ngdialog-closing');
                        } else {
                            scope.$destroy();
                            $dialog.remove();
                            if (dialogsCount === 0) {
                                $body.removeClass('ngdialog-open');
                                privateMethods.resetBodyPadding();
                            }
                            $rootScope.$broadcast('ngDialog.closed', $dialog);
                        }
                        if (defers[id]) {
                            defers[id].resolve({
                                id: id,
                                value: value,
                                $dialog: $dialog,
                                remainingDialogs: dialogsCount
                            });
                            delete defers[id];
                        }
                    },

                    closeDialog: function ($dialog, value) {
                        var preCloseCallback = $dialog.data('$ngDialogPreCloseCallback');

                        if (preCloseCallback && angular.isFunction(preCloseCallback)) {

                            var preCloseCallbackResult = preCloseCallback.call($dialog, value);

                            if (angular.isObject(preCloseCallbackResult)) {
                                if (preCloseCallbackResult.closePromise) {
                                    preCloseCallbackResult.closePromise.then(function () {
                                        privateMethods.performCloseDialog($dialog, value);
                                    });
                                } else {
                                    preCloseCallbackResult.then(function () {
                                        privateMethods.performCloseDialog($dialog, value);
                                    }, function () {
                                        return;
                                    });
                                }
                            } else if (preCloseCallbackResult !== false) {
                                privateMethods.performCloseDialog($dialog, value);
                            }
                        } else {
                            privateMethods.performCloseDialog($dialog, value);
                        }
                    },

                    onTrapFocusKeydown: function (ev) {
                        var el = angular.element(ev.currentTarget);
                        var $dialog;

                        if (el.hasClass('ngdialog')) {
                            $dialog = el;
                        } else {
                            $dialog = privateMethods.getActiveDialog();

                            if ($dialog === null) {
                                return;
                            }
                        }

                        var isTab = (ev.keyCode === 9);
                        var backward = (ev.shiftKey === true);

                        if (isTab) {
                            privateMethods.handleTab($dialog, ev, backward);
                        }
                    },

                    handleTab: function ($dialog, ev, backward) {
                        var focusableElements = privateMethods.getFocusableElements($dialog);

                        if (focusableElements.length === 0) {
                            if (document.activeElement) {
                                document.activeElement.blur();
                            }
                            return;
                        }

                        var currentFocus = document.activeElement;
                        var focusIndex = Array.prototype.indexOf.call(focusableElements, currentFocus);

                        var isFocusIndexUnknown = (focusIndex === -1);
                        var isFirstElementFocused = (focusIndex === 0);
                        var isLastElementFocused = (focusIndex === focusableElements.length - 1);

                        var cancelEvent = false;

                        if (backward) {
                            if (isFocusIndexUnknown || isFirstElementFocused) {
                                focusableElements[focusableElements.length - 1].focus();
                                cancelEvent = true;
                            }
                        } else {
                            if (isFocusIndexUnknown || isLastElementFocused) {
                                focusableElements[0].focus();
                                cancelEvent = true;
                            }
                        }

                        if (cancelEvent) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                    },

                    autoFocus: function ($dialog) {
                        var dialogEl = $dialog[0];

                        // Browser's (Chrome 40, Forefix 37, IE 11) don't appear to honor autofocus on the dialog, but we should
                        var autoFocusEl = dialogEl.querySelector('*[autofocus]');
                        if (autoFocusEl !== null) {
                            autoFocusEl.focus();

                            if (document.activeElement === autoFocusEl) {
                                return;
                            }

                            // Autofocus element might was display: none, so let's continue
                        }

                        var focusableElements = privateMethods.getFocusableElements($dialog);

                        if (focusableElements.length > 0) {
                            focusableElements[0].focus();
                            return;
                        }

                        // We need to focus something for the screen readers to notice the dialog
                        var contentElements = privateMethods.filterVisibleElements(dialogEl.querySelectorAll('h1,h2,h3,h4,h5,h6,p,span'));

                        if (contentElements.length > 0) {
                            var contentElement = contentElements[0];
                            $el(contentElement).attr('tabindex', '0');
                            contentElement.focus();
                        }
                    },

                    getFocusableElements: function ($dialog) {
                        var dialogEl = $dialog[0];

                        var rawElements = dialogEl.querySelectorAll(focusableElementSelector);

                        return privateMethods.filterVisibleElements(rawElements);
                    },

                    filterVisibleElements: function (els) {
                        var visibleFocusableElements = [];

                        for (var i = 0; i < els.length; i++) {
                            var el = els[i];

                            if (el.offsetWidth > 0 || el.offsetHeight > 0) {
                                visibleFocusableElements.push(el);
                            }
                        }

                        return visibleFocusableElements;
                    },

                    getActiveDialog: function () {
                        var dialogs = document.querySelectorAll('.ngdialog');

                        if (dialogs.length === 0) {
                            return null;
                        }

                        // TODO: This might be incorrect if there are a mix of open dialogs with different 'appendTo' values
                        return $el(dialogs[dialogs.length - 1]);
                    },

                    applyAriaAttributes: function ($dialog, options) {

                        if (options.ariaAuto) {
                            if (!options.ariaRole) {
                                var detectedRole = (privateMethods.getFocusableElements($dialog).length > 0) ?
                                    'dialog' :
                                    'alertdialog';

                                options.ariaRole = detectedRole;
                            }

                            if (!options.ariaLabelledBySelector) {
                                options.ariaLabelledBySelector = 'h1,h2,h3,h4,h5,h6';
                            }

                            if (!options.ariaDescribedBySelector) {
                                options.ariaDescribedBySelector = 'article,section,p';
                            }
                        }

                        if (options.ariaRole) {
                            $dialog.attr('role', options.ariaRole);
                        }

                        privateMethods.applyAriaAttribute(
                            $dialog, 'aria-labelledby', options.ariaLabelledById, options.ariaLabelledBySelector);

                        privateMethods.applyAriaAttribute(
                            $dialog, 'aria-describedby', options.ariaDescribedById, options.ariaDescribedBySelector);
                    },

                    applyAriaAttribute: function ($dialog, attr, id, selector) {
                        if (id) {
                            $dialog.attr(attr, id);
                        }

                        if (selector) {
                            var dialogId = $dialog.attr('id');

                            var firstMatch = $dialog[0].querySelector(selector);

                            if (!firstMatch) {
                                return;
                            }

                            var generatedId = dialogId + '-' + attr;

                            $el(firstMatch).attr('id', generatedId);

                            $dialog.attr(attr, generatedId);

                            return generatedId;
                        }
                    }
                };

                var publicMethods = {

                    /*
                     * @param {Object} options:
                     * - template {String} - id of ng-template, url for partial, plain string (if enabled)
                     * - plain {Boolean} - enable plain string templates, default false
                     * - scope {Object}
                     * - controller {String}
                     * - className {String} - dialog theme class
                     * - showClose {Boolean} - show close button, default true
                     * - closeByEscape {Boolean} - default true
                     * - closeByDocument {Boolean} - default true
                     * - preCloseCallback {String|Function} - user supplied function name/function called before closing dialog (if set)
                     *
                     * @return {Object} dialog
                     */
                    open: function (opts) {
                        var self = this;
                        var options = angular.copy(defaults);

                        opts = opts || {};
                        angular.extend(options, opts);

                        globalID += 1;

                        self.latestID = 'ngdialog' + globalID;

                        var defer;
                        defers[self.latestID] = defer = $q.defer();

                        scope = angular.isObject(options.scope) ? options.scope.$new() : $rootScope.$new();
                        var $dialog, $dialogParent;

                        $q.when(loadTemplate(options.template || options.templateUrl)).then(function (template) {

                            $templateCache.put(options.template || options.templateUrl, template);

                            if (options.showClose) {
                                template += '<div class="ngdialog-close"></div>';
                            }

                            self.$result = $dialog = $el('<div id="ngdialog' + globalID + '" class="ngdialog"></div>');
                            $dialog.html((options.overlay ?
                                '<div class="ngdialog-overlay"></div><div class="ngdialog-content" role="document">' + template + '</div>' :
                                '<div class="ngdialog-content" role="document">' + template + '</div>'));

                            $dialog.data('$ngDialogOptions', options);

                            if (options.data && angular.isString(options.data)) {
                                var firstLetter = options.data.replace(/^\s*/, '')[0];
                                scope.ngDialogData = (firstLetter === '{' || firstLetter === '[') ? angular.fromJson(options.data) : options.data;
                            } else if (options.data && angular.isObject(options.data)) {
                                scope.ngDialogData = options.data;
                            }

                            if (options.controller && (angular.isString(options.controller) || angular.isArray(options.controller) || angular.isFunction(options.controller))) {
                                var controllerInstance = $controller(options.controller, {
                                    $scope: scope,
                                    $element: $dialog
                                });
                                $dialog.data('$ngDialogControllerController', controllerInstance);
                            }

                            if (options.className) {
                                $dialog.addClass(options.className);
                            }

                            if (options.appendTo && angular.isString(options.appendTo)) {
                                $dialogParent = angular.element(document.querySelector(options.appendTo));
                            } else {
                                $dialogParent = $body;
                            }

                            privateMethods.applyAriaAttributes($dialog, options);

                            if (options.preCloseCallback) {
                                var preCloseCallback;

                                if (angular.isFunction(options.preCloseCallback)) {
                                    preCloseCallback = options.preCloseCallback;
                                } else if (angular.isString(options.preCloseCallback)) {
                                    if (scope) {
                                        if (angular.isFunction(scope[options.preCloseCallback])) {
                                            preCloseCallback = scope[options.preCloseCallback];
                                        } else if (scope.$parent && angular.isFunction(scope.$parent[options.preCloseCallback])) {
                                            preCloseCallback = scope.$parent[options.preCloseCallback];
                                        } else if ($rootScope && angular.isFunction($rootScope[options.preCloseCallback])) {
                                            preCloseCallback = $rootScope[options.preCloseCallback];
                                        }
                                    }
                                }

                                if (preCloseCallback) {
                                    $dialog.data('$ngDialogPreCloseCallback', preCloseCallback);
                                }
                            }

                            scope.closeThisDialog = function (value) {
                                privateMethods.closeDialog($dialog, value);
                            };

                            $timeout(function () {
                                var $activeDialogs = document.querySelectorAll('.ngdialog');
                                privateMethods.deactivateAll($activeDialogs);

                                $compile($dialog)(scope);
                                var widthDiffs = $window.innerWidth - $body.prop('clientWidth');
                                $body.addClass('ngdialog-open');
                                var scrollBarWidth = widthDiffs - ($window.innerWidth - $body.prop('clientWidth'));
                                if (scrollBarWidth > 0) {
                                    privateMethods.setBodyPadding(scrollBarWidth);
                                }
                                $dialogParent.append($dialog);

                                privateMethods.activate($dialog);

                                if (options.trapFocus) {
                                    privateMethods.autoFocus($dialog);
                                }

                                if (options.name) {
                                    $rootScope.$broadcast('ngDialog.opened', { dialog: $dialog, name: options.name });
                                } else {
                                    $rootScope.$broadcast('ngDialog.opened', $dialog);
                                }
                            });

                            if (options.closeByEscape) {
                                $body.bind('keydown', privateMethods.onDocumentKeydown);
                            }

                            if (options.closeByNavigation) {
                                $rootScope.$on('$locationChangeSuccess', function () {
                                    privateMethods.closeDialog($dialog);
                                });
                            }

                            if (options.preserveFocus) {
                                $dialog.data('$ngDialogPreviousFocus', document.activeElement);
                            }

                            closeByDocumentHandler = function (event) {
                                var isOverlay = options.closeByDocument ? $el(event.target).hasClass('ngdialog-overlay') : false;
                                var isCloseBtn = $el(event.target).hasClass('ngdialog-close');

                                if (isOverlay || isCloseBtn) {
                                    publicMethods.close($dialog.attr('id'), isCloseBtn ? '$closeButton' : '$document');
                                }
                            };

                            if (typeof $window.Hammer !== 'undefined') {
                                var hammerTime = scope.hammerTime = $window.Hammer($dialog[0]);
                                hammerTime.on('tap', closeByDocumentHandler);
                            } else {
                                $dialog.bind('click', closeByDocumentHandler);
                            }

                            dialogsCount += 1;

                            return publicMethods;
                        });

                        return {
                            id: 'ngdialog' + globalID,
                            closePromise: defer.promise,
                            close: function (value) {
                                privateMethods.closeDialog($dialog, value);
                            }
                        };

                        function loadTemplateUrl(tmpl, config) {
                            return $http.get(tmpl, (config || {})).then(function (res) {
                                return res.data || '';
                            });
                        }

                        function loadTemplate(tmpl) {
                            if (!tmpl) {
                                return 'Empty template';
                            }

                            if (angular.isString(tmpl) && options.plain) {
                                return tmpl;
                            }

                            if (typeof options.cache === 'boolean' && !options.cache) {
                                return loadTemplateUrl(tmpl, { cache: false });
                            }

                            return $templateCache.get(tmpl) || loadTemplateUrl(tmpl, { cache: true });
                        }
                    },

                    /*
                     * @param {Object} options:
                     * - template {String} - id of ng-template, url for partial, plain string (if enabled)
                     * - plain {Boolean} - enable plain string templates, default false
                     * - name {String}
                     * - scope {Object}
                     * - controller {String}
                     * - className {String} - dialog theme class
                     * - showClose {Boolean} - show close button, default true
                     * - closeByEscape {Boolean} - default false
                     * - closeByDocument {Boolean} - default false
                     * - preCloseCallback {String|Function} - user supplied function name/function called before closing dialog (if set); not called on confirm
                     *
                     * @return {Object} dialog
                     */
                    openConfirm: function (opts) {
                        var defer = $q.defer();

                        var options = {
                            closeByEscape: false,
                            closeByDocument: false
                        };
                        angular.extend(options, opts);

                        options.scope = angular.isObject(options.scope) ? options.scope.$new() : $rootScope.$new();
                        options.scope.confirm = function (value) {
                            defer.resolve(value);
                            var $dialog = $el(document.getElementById(openResult.id));
                            privateMethods.performCloseDialog($dialog, value);
                        };

                        var openResult = publicMethods.open(options);
                        openResult.closePromise.then(function (data) {
                            if (data) {
                                return defer.reject(data.value);
                            }
                            return defer.reject();
                        });

                        return defer.promise;
                    },

                    /*
                     * @param {String} id
                     * @return {Object} dialog
                     */
                    close: function (id, value) {
                        var $dialog = $el(document.getElementById(id));

                        if ($dialog.length) {
                            privateMethods.closeDialog($dialog, value);
                        } else {
                            publicMethods.closeAll(value);
                        }

                        return publicMethods;
                    },

                    closeAll: function (value) {
                        var $all = document.querySelectorAll('.ngdialog');

                        // Reverse order to ensure focus restorationi works as expected
                        for (var i = $all.length; i > -1; i--) {
                            var dialog = $all[i];
                            privateMethods.closeDialog($el(dialog), value);
                        }
                    },

                    getDefaults: function () {
                        return defaults;
                    }
                };

                return publicMethods;
            }];
    });

    m.directive('ngDialog', ['ngDialog', function (ngDialog) {
        return {
            restrict: 'A',
            scope: {
                ngDialogScope: '='
            },
            link: function (scope, elem, attrs) {
                elem.on('click', function (e) {
                    e.preventDefault();

                    var ngDialogScope = angular.isDefined(scope.ngDialogScope) ? scope.ngDialogScope : 'noScope';
                    angular.isDefined(attrs.ngDialogClosePrevious) && ngDialog.close(attrs.ngDialogClosePrevious);

                    var defaults = ngDialog.getDefaults();

                    ngDialog.open({
                        template: attrs.ngDialog,
                        className: attrs.ngDialogClass || defaults.className,
                        controller: attrs.ngDialogController,
                        scope: ngDialogScope,
                        data: attrs.ngDialogData,
                        showClose: attrs.ngDialogShowClose === 'false' ? false : (attrs.ngDialogShowClose === 'true' ? true : defaults.showClose),
                        closeByDocument: attrs.ngDialogCloseByDocument === 'false' ? false : (attrs.ngDialogCloseByDocument === 'true' ? true : defaults.closeByDocument),
                        closeByEscape: attrs.ngDialogCloseByEscape === 'false' ? false : (attrs.ngDialogCloseByEscape === 'true' ? true : defaults.closeByEscape),
                        preCloseCallback: attrs.ngDialogPreCloseCallback || defaults.preCloseCallback
                    });
                });
            }
        };
    }]);

    return m;
}));
